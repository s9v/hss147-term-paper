{"status":"OK","result":{"originalLocale":"ru","allowViewHistory":true,"creationTimeSeconds":1516604325,"rating":1,"authorHandle":"Pollux","modificationTimeSeconds":1516632367,"id":57276,"title":"\u003cp\u003eTree\u003c/p\u003e","locale":"ru","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003ch4\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eDSU\u003c/i\u003e\u003c/span\u003e(Sack on tree)\u003c/h4\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/600/problem/E\"\u003eProblem\u003c/a\u003e\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eImplementation\u003c/i\u003e\u003c/span\u003e \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;bits/stdc++.h\u0026gt;\t\t\t\n\n#define pb push_back\n#define pp pop_back\n#define sz(a) (int)(a.size())\n#define mp make_pair\n#define F first\n#define S second\n#define next _next\n#define prev _prev\n#define left _left\n#define right _right\n#define y1 _y1\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair\u0026lt;int, int\u0026gt; pii;\ntypedef pair\u0026lt;ll, ll\u0026gt; pll;\n\nconst int N \u003d (int)1e6 + 123;\nconst ll INF \u003d (ll)1e18 + 123;\nconst int inf \u003d (int)1e9 + 123;\nconst int MOD \u003d (int)1e9 + 7;\n\nvoid megaRandom() {\n\tunsigned int FOR;\n \tasm(\u0026quot;rdtsc\u0026quot; : \u0026quot;\u003dA\u0026quot;(FOR));\n  \tsrand(FOR);\n}\n\nint n, c[N];\nvector\u0026lt;int\u0026gt; g[N];\nint sub[N];\n\nvoid jfs(int x, int p \u003d -1) {\n\tsub[x] \u003d 1;\n\tfor(auto to : g[x]) {\n\t\tif(to \u003d\u003d p) continue;\n\t\tjfs(to, x);\n\t\tsub[x] +\u003d sub[to];\n\t}\n}\n\nmap\u0026lt;int, int\u0026gt; *cnt[N];\n\nvoid dfs(int x, int p \u003d -1) {\n\tfor(auto to : g[x]) {\n\t\tif(to \u003d\u003d p) continue;\n\t\tdfs(to, x);\n\t}\n\tint mx_v \u003d -1, mx \u003d 0;\n\tfor(auto to : g[x]) {\t\n\t\tif(to \u003d\u003d p) continue;\n\t\tif(mx \u0026lt; sub[to])\n\t\t\tmx_v \u003d to, mx \u003d sub[to];\n\t}\n\tif(mx_v !\u003d -1) {\n\t\tcnt[x] \u003d cnt[mx_v];\t\t\t\t\n\t} else \n\t\tcnt[x] \u003d new map\u0026lt;int, int\u0026gt;;\n\t(*cnt[x])[c[x]] ++;\n\tfor(auto to : g[x]) {\n\t\tif(to \u003d\u003d p || to \u003d\u003d mx_v)\n\t\t\tcontinue;\n\t\tfor(auto z : *cnt[to]) {\n\t\t\t(*cnt[x])[z.F] +\u003d z.S;\n\t\t}\t                   \t\n\t}\n}\n\nint main() {\n\tmegaRandom();\n\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i ++)\n\t\tscanf(\u0026quot;%d\u0026quot;, \u0026amp;c[i]);\n\tfor(int i \u003d 1, x, y; i \u0026lt; n; i ++) {\n\t\tscanf(\u0026quot;%d%d\u0026quot;, \u0026amp;x, \u0026amp;y);\n\t\tg[x].pb(y), g[y].pb(x);\t\t\n\t}\n\tjfs(1);\n\tdfs(1);\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i ++)\n\t\tprintf(\u0026quot;%lld \u0026quot;, mx_val[i]);\n\t\t//cout \u0026lt;\u0026lt; \u0026quot;i: \u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; mx_val[i]: \u0026quot; \u0026lt;\u0026lt; mx_val[i] \u0026lt;\u0026lt; \u0026quot; mx_cnt[i]: \u0026quot; \u0026lt;\u0026lt; mx_cnt[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d \u003c/p\u003e\u003ch4\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eCentroid\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003eNlogN\u003c/i\u003e)\u003c/span\u003e\u003c/h4\u003e\u003cp\u003e\u003ca href\u003d\"http://https://www.codechef.com/problems/PRIMEDST\"\u003eProblem\u003c/a\u003e\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eImplementation\u003c/i\u003e\u003c/span\u003e \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;           \n#include \u0026lt;stdio.h\u0026gt;\n \n#define pb push_back\n#define pp pop_back\n#define sz(a) (int)(a.size())\n#define mp make_pair\n#define F first\n#define S second\n#define next nneexxtt\n#define left lleefftt\n#define right rriigghht\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair\u0026lt;int, int\u0026gt; pii;\n \nconst int N \u003d (int)1e5 + 123;\nconst ll INF \u003d (ll)1e18 + 123;\nconst int inf \u003d (int)1e9 + 123;\n \nint n, m, sub[100011];\nvector\u0026lt;int\u0026gt; g[100011];\nbool del[100011];\n \nvoid dfs(int x, int par \u003d -1) {\n    sub[x] \u003d 1;\n    for(auto to : g[x]) {\n        if(to \u003d\u003d par || del[to]) continue;\n        dfs(to, x);\n        sub[x] +\u003d sub[to];      \n    }\n}\n \nint get_centroid(int x) {  \n    bool ch;\n    int now \u003d x, Sz \u003d sub[x], par \u003d -1;\n    while(1) {\n        ch \u003d 0;\n        for(auto to : g[now]) {\n            if(to \u003d\u003d par || del[to]) continue;\n            if(sub[to] * 2 \u0026gt;\u003d Sz) {\n                par \u003d now, now \u003d to, ch \u003d 1;\n                break;\n         } \n        }\n        if(!ch) break;\n    }\n    return now;\n}\n \nvoid show(int x, int par \u003d -1) {\n    cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n    for(auto to : g[x]) {\n        if(to \u003d\u003d par || del[to]) continue;\n        show(to, x);\n    }\n}\n \nvoid calc(int x, int par \u003d -1) {\n    dfs(x);\n    x \u003d get_centroid(x);\n    cout \u0026lt;\u0026lt; \u0026quot;\\n\\nCentroid: \u0026quot; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026quot; Tree:\\n\u0026quot;;\n    show(x);\n    del[x] \u003d 1;\n    for(auto to : g[x]) {\n        if(del[to] || to \u003d\u003d par) continue;\n        calc(to, x);\n    }\n}  \n \nint main() {\n    cin \u0026gt;\u0026gt; n;\n    for(int i \u003d 1, a, b; i \u0026lt;\u003d n - 1; i ++) {\n        cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; \n        g[a].pb(b);\n        g[b].pb(a);\n    }      \n    calc(1);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d \u003c/p\u003e\u003ch4\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eMo\u003c/i\u003e\u0027\u003ci\u003es\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ealgorithm\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eon\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etree\u003c/i\u003e\u003c/span\u003e\u003c/h4\u003e\u003cp\u003e\u003ca href\u003d\"http://www.spoj.com/problems/COT2/\"\u003eProblem\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d \u003c/p\u003e\u003ch4\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eSqrt\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eUpdate\u003c/i\u003e\u003c/span\u003e\u003c/h4\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/contest/342/problem/E\"\u003eProblem\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003c/p\u003e\u003ch4\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eST\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eon\u003c/i\u003e\u003c/span\u003e \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003etree\u003c/i\u003e\u003c/span\u003e\u003c/h4\u003e\u003cp\u003e\u003ca href\u003d\"//codeforces.com/problemset/problem/343/D?locale\u003dru\"\u003eProblem\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003c/p\u003e\u003ch4\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eHLD\u003c/i\u003e\u003c/span\u003e \u003ca href\u003d\"https://github.com/sindresorhus/awesome\"\u003e\u003cimg alt\u003d\"Awesome\" src\u003d\"/predownloaded/67/aa/67aad24db041f8e850d074e0216eaf8ecbf7fa20.svg\" style\u003d\"max-width: 100.0%;max-height: 100.0%;\" /\u003e\u003c/a\u003e\u003c/h4\u003e\u003cp\u003e\u003ca href\u003d\"https://blog.anudeep2011.com/heavy-light-decomposition/\"\u003eSuper Tutorial\u003c/a\u003e\u003cbr /\u003e\u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eProblems\u003c/i\u003e\u003c/span\u003e â€” You can find them on that blog\u003cbr /\u003eMy Implementation \u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eSpoiler\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;bits/stdc++.h\u0026gt;\t\t\t\n\n#define pb push_back\n#define pf push_front\n#define pp pop_back\n#define sz(a) (int)(a.size())\n#define mp make_pair\n#define F first\n#define S second\n#define next _next\n#define prev _prev\n#define left _left\n#define right _right\n#define y1 _y1\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair\u0026lt;int, int\u0026gt; pii;\ntypedef pair\u0026lt;ll, ll\u0026gt; pll;\n\nconst int N \u003d (int)1e4 + 123;\nconst ll INF \u003d (ll)1e18 + 123;\nconst int inf \u003d (int)1e9 + 123;\nconst int MOD \u003d (int)1e9 + 7;\n\nvoid megaRandom() {\n\tunsigned int FOR;\n \tasm(\u0026quot;rdtsc\u0026quot; : \u0026quot;\u003dA\u0026quot;(FOR));\n  \tsrand(FOR);\n}\n\nint n, timer, tin[N], tout[N], sub[N];\nvector\u0026lt;pii\u0026gt; g[(int)1e4+5];\nint up[16][N];\nint clr, color[N], name[N];\nvector\u0026lt;int\u0026gt; group[N];\nint cost[N];\nint t[4*N];\n\nvoid dfs(int x, int pr \u003d 0) {\n\ttin[x] \u003d ++ timer;\n\tup[0][x] \u003d pr;\n\tfor(int i \u003d 1; i \u0026lt;\u003d 15; i ++)\n\t\tup[i][x] \u003d up[i - 1][up[i - 1][x]];\n\tsub[x] \u003d 1;\t\n\tfor(auto to : g[x]) {\n\t\tif(to.F \u003d\u003d pr) {\n\t\t\tcost[x] \u003d to.S;\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to.F, x);\n\t\tsub[x] +\u003d sub[to.F];\t\t  \t\n\t}\t\t\n\ttout[x] \u003d ++ timer;\n}\n\nvoid hld(int x, int pr \u003d 0) {\n\tint heavy \u003d 0;\n\tfor(auto to : g[x]) {\n\t\tif(to.F \u003d\u003d pr) continue;\n\t\tif(sub[to.F] * 2 \u0026gt;\u003d sub[x])\n\t\t\theavy \u003d to.F;\n\t\telse\n\t\t\thld(to.F, x);\t\t\n\t}\n\tif(heavy) {\n\t\thld(heavy, x);\n\t\tcolor[x] \u003d color[heavy];\n\t} else \n\t\tcolor[x] \u003d ++ clr;\t\t\n\tgroup[ color[x] ].pb(x);\n}\n\nvoid refresh() {\n\ttimer \u003d 0, clr \u003d 0;\n\tfor(int i \u003d 1; i \u0026lt;\u003d n; i ++)\n\t\tg[i].clear(), group[i].clear();\n\tmemset(t, 0, sizeof t);\n}\n\nbool is_parent(int a, int b) {\n\treturn (tin[a] \u0026lt;\u003d tin[b] \u0026amp;\u0026amp; tout[a] \u0026gt;\u003d tout[b]);\n}\n\nint lca(int a, int b) {\n\tif(is_parent(a, b)) return a;\n\tif(is_parent(b, a)) return b;\n\tint v \u003d a;\n\tfor(int i \u003d 15; i \u0026gt;\u003d 0; i --)\n\t\tif(up[i][v] \u0026amp;\u0026amp; !is_parent(up[i][v], b))\n\t\t\tv \u003d up[i][v];\n\treturn up[0][v];\n}\n\nvoid upd(int pos, int val, int v \u003d 1, int tl \u003d 1, int tr \u003d n) {\n\tif(tl \u003d\u003d tr) {\n\t\tt[v] \u003d val;\n\t\treturn;\n\t}   \n\tint mid \u003d (tl + tr) \u0026gt;\u0026gt; 1;\n\tif(pos \u0026lt;\u003d mid) upd(pos, val, (v \u0026lt;\u0026lt; 1), tl, mid);\n\telse           upd(pos, val, (v \u0026lt;\u0026lt; 1) + 1, mid + 1, tr);\n\tt[v] \u003d max(t[(v \u0026lt;\u0026lt; 1)], t[(v \u0026lt;\u0026lt; 1) + 1]);\n}\n\nint get(int l, int r, int v \u003d 1, int tl \u003d 1, int tr \u003d n) {\n\tif(tl \u0026gt; r || l \u0026gt; tr)\n\t\treturn -inf;\n\tif(l \u0026lt;\u003d tl \u0026amp;\u0026amp; tr \u0026lt;\u003d r)\n\t\treturn t[v];\n\tint mid \u003d (tl + tr) \u0026gt;\u0026gt; 1;\n\treturn max(get(l, r, (v \u0026lt;\u0026lt; 1), tl, mid), get(l, r, (v \u0026lt;\u0026lt; 1) + 1, mid + 1, tr));\n}\n\nint query(int a, int b) {\n\tint _lca \u003d lca(a, b);\n\tint res \u003d -inf;\n\t//cout \u0026lt;\u0026lt; \u0026quot;a:\u0026quot; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot; b: \u0026quot; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026quot; lca: \u0026quot; \u0026lt;\u0026lt; lca \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\twhile(color[a] !\u003d color[_lca]) {\n\t\tint king \u003d group[color[a]].back();\n\t\tint l \u003d name[a], r \u003d name[king];\n\t\tres \u003d max(res, get(l, r));\n\t\ta \u003d up[0][king];\n\t}\n\t\n\twhile(color[b] !\u003d color[_lca]) {\n\t\tint king \u003d group[color[b]].back();\n\t\tint l \u003d name[b], r \u003d name[king];\n\t\tres \u003d max(res, get(l, r));\n\t\tb \u003d up[0][king];\n\t}   \n\tint l \u003d name[a], r \u003d name[_lca];\n\tres \u003d max(res, get(l, r - 1));\n\tl \u003d name[b], r \u003d name[_lca];\n\tres \u003d max(res, get(l, r - 1));\n\treturn res;      \n}\n\npii edge[N];\n\nvoid solve() {\n\tcin \u0026gt;\u0026gt; n;//scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\trefresh();\n\tfor(int i \u003d 1, x, y, z; i \u0026lt; n; i ++) {\n\t\tcin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z;//scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;x, \u0026amp;y, \u0026amp;z);\n\t\tg[x].pb(mp(y, z));\n\t\tg[y].pb(mp(x, z));\n\t\tedge[i] \u003d mp(x, y);\n\t}\t\n\tdfs(1);\n\thld(1);\n\tint ptr \u003d 0;\n\tfor(int i \u003d 1; i \u0026lt;\u003d clr; i ++) {\n\t\t//reverse(all(group[i]));\n\t\tfor(auto x : group[i]) {\n\t\t\t//cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026quot; cost: \u0026quot; \u0026lt;\u0026lt; cost[x] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;;\n\t\t\tname[x] \u003d ++ ptr;\t\t\t\n\t\t\tupd(ptr, cost[x]);\n\t\t}\n\t\t//reverse(all(group[i]));\n\t}\n\t//cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\n\tstring s;\n\tint x, y;\n\twhile(1) {\n\t\tcin \u0026gt;\u0026gt; s;\n\t\tif(s \u003d\u003d \u0026quot;DONE\u0026quot;)\n\t\t\tbreak;\n\t\tcin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y;\n\t\tif(s \u003d\u003d \u0026quot;CHANGE\u0026quot;) {\n\t\t\tint a \u003d edge[x].F, b \u003d edge[x].S;\n\t\t\tif(is_parent(b, a)) swap(a, b);\n\t\t\tupd(name[b], y);\n\t\t} \n\t\tif(s \u003d\u003d \u0026quot;QUERY\u0026quot;) {\n\t\t\tcout \u0026lt;\u0026lt; query(x, y) \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;;\t\t\t\t\t\n\t\t}\n\t}         \n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tmegaRandom();\n\tint t;\n\tcin \u0026gt;\u0026gt; t;//scanf(\u0026quot;%d\u0026quot;, \u0026amp;t);\n\twhile(t --)\n\t\tsolve();\t\t\t\t\n\treturn 0;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e","tags":[]}}