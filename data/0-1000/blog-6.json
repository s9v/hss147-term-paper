{"status":"OK","result":{"originalLocale":"en","allowViewHistory":false,"creationTimeSeconds":1264793484,"rating":12,"authorHandle":"stingray","modificationTimeSeconds":1264793484,"id":6,"title":"Accurate memory accounting for programming contests (part 1)","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cspan style\u003d\"font-family: arial , sans-serif;font-size: small;\"\u003e   \u003cp\u003eThe memory accounting is the part of programming contest     environment which is almost never done right. And even if it\u0027s done     right, it doesn\u0027t seems so to the extent that people will complain     about it. A lot.\u003c/p\u003e   \u003cp\u003eSo let\u0027s start with choosing our platform first (Windows), and     briefly describe the most common mistakes people do (aside from     saying \u0026quot;contest platform is simple, I\u0027ll write one in no time\u0026quot;).\u003c/p\u003e   \u003ch2\u003eChapter 1, in which we learn how to do \u003ca style\u003d\"font-family: arial , sans-serif;color: rgb(0,62,168);\"\u003eGetProcessMemoryInfo\u003c/a\u003e\u003c/h2\u003e   \u003cp\u003e     \u003ca style\u003d\"font-family: arial , sans-serif;color: rgb(0,62,168);\"\u003eCreateProcess\u003c/a\u003e (and     similar functions) give us this handle, which we can later use       in \u003ca style\u003d\"font-family: arial , sans-serif;color: rgb(0,62,168);\"\u003eGetProcessMemoryInfo\u003c/a\u003e call,     which will in turn give us \u003ca style\u003d\"font-family: arial , sans-serif;color: rgb(0,62,168);\"\u003ePROCESS_MEMORY_COUNTERS\u003c/a\u003e structure     filled with useful data. So, the very first mistake would be to use     PeakWorkingSetSize field to measure the memory usage.\u003c/p\u003e   \u003cp\u003eThis is plain wrong.\u003c/p\u003e   \u003cp\u003e\u0026quot;Working set\u0026quot; is the set of physical pages in memory that     exist in the address space of the process. So in other words, if the     process allocated tons of memory but it\u0027s all swapped out - you     won\u0027t see it. If the process did not allocate anything but is for     some reason linked to a DLL with huge .DATA segment, and touched     lots of pages - you will probably see it. Also, Windows VM tries to     do tricks to a working set - you can put arbitrary per-process     limits on it, and of course when memory pressure is above some     threshold your data can be swapped out and pages will be discarded     from it. Bottom line, measuring process memory usage by looking at     the working set will get you nowhere.\u003c/p\u003e   \u003ch2\u003eChapter 2, in which we learn to access the correct fields       in \u003ca style\u003d\"font-family: arial , sans-serif;color: rgb(0,62,168);\"\u003ePROCESS_MEMORY_COUNTERS\u003c/a\u003e\u003c/h2\u003e   \u003cp\u003eWindows memory management has this wonderful no-overcommit     property, which means that if you enabled pagefile, then all memory     you allocate will be backed by it. Or, from a different angle, every     page in your address space is either represented by kernel (and you     don\u0027t care), backed by some file somewhere (like your binary image),     or backed by a file with handle -1 (that\u0027s somewhere in pagefile).     So here\u0027s what you need to look at: PeakPagefileUsage.\u003c/p\u003e   \u003cp\u003eThis will give you the correct value for anonymous memory (backed     by the pagefile). But you still have to guard yourself against     cheaters, who will create a file and use \u003ca style\u003d\"font-family: arial , sans-serif;color: rgb(0,62,168);\"\u003eCreateFileMapping\u003c/a\u003e to     obtain some memory which will be not accounted as PagefileUsage.\u003c/p\u003e   \u003ch2\u003eChapter 3, in which we learn Java\u003c/h2\u003e   \u003cp\u003eThis chapter is not unique to Java. It is common to any     implementation that maintains its own heap. Low-level windows memory     management (VirtualAlloc and friends) are giving out memory in     pages. So, to allocate arbitrary structures, everything uses some     kind of heap manager. Windows has its own one (HeapAlloc and     friends), but some other languages and runtimes may decide to     implement theirs. For a lazy heap implementation, or some other kind     which tries to reduce fragmentation (like the firefox one) the     observed memory usage can be much worse than the real one     (from the high-level programmer point of view).\u003c/p\u003e   \u003cp\u003eThis is especially true with Java as it\u0027s not being run directly on     the platform and includes its own sophisticated memory management     with garbage collection and whatnot. So, you cannot trust the     numbers Windows gives you for Java binaries. What you have to do     instead is to limit size of the Java heap to your memory limit, and     catch the OutOfMemory exception for solutions.\u003c/p\u003e   \u003cp\u003eAs an additional improvement, you may want to create a JVM agent     and inject it into your process, to monitor and collect the memory     usage of your Java process inside the JVM, because windows will     always report that it used all memory you gave it.\u003c/p\u003e   \u003ch2\u003eChapter 4, in which we don\u0027t want \u003ca style\u003d\"font-family: arial , sans-serif;color: rgb(0,62,168);\"\u003ejob objects\u003c/a\u003e\u003c/h2\u003e   \u003cp\u003eJob objects are nice when you want to isolate your processes from     each other and prevent the whole system from exploding.     Unfortunately they are not that good in our case. What they do when     you limit the memory size is they deny memory allocations by forcing     alloc and realloc (and mmap fwiw) functions to return     NULL. And in modern computing, almost nothing handles this properly,     including Windows itself. So, if you put a limit too tight, and your     application has a huge data segment which inflates when system is     initially trying to mmap your binary, the app won\u0027t even load,     CreateProcess will fail with a bizarre error message in MessageBox     (obviously we want someone to sit in front of the server every time     we run out of memory quota, thank you Microsoft). So, while we\u0027re OK     with using job objects to isolate UI elements and do a     post-execution accounting of launched processes, we don\u0027t really     want to use memory limits there.\u003c/p\u003e   \u003ch2\u003eConclusion, in which we write contest platform in no time\u003c/h2\u003e   \u003cp\u003eThanks to this writeup, we have successfully clarified this tricky     and obscure thing - memory limits. So, I guess, we\u0027re     quite ready to write our own contester? Of course, it will be     Windows-only, will launch everything as an admin user, won\u0027t do     process time accounting, ...\u003c/p\u003e   \u003cp\u003eOr you can watch this blog for a next one, in which we\u0027ll discuss     one of:\u003c/p\u003e   \u003cul\u003e     \u003cli\u003ememory accounting on Linux\u003c/li\u003e     \u003cli\u003eCPU time accounting in Windows and Linux\u003c/li\u003e     \u003cli\u003eprocess isolation in Windows and Linux\u003c/li\u003e     \u003cli\u003esomething else.\u003cspan\u003e \u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/span\u003e\u003c/div\u003e","tags":["contester","win32"]}}