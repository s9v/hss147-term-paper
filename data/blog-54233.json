{"status":"OK","result":{"originalLocale":"en","allowViewHistory":true,"creationTimeSeconds":1504282069,"rating":214,"authorHandle":"cyand1317","modificationTimeSeconds":1504429119,"id":54233,"title":"\u003cp\u003eCodeforces Round #431 Editorial\u003c/p\u003e","locale":"en","content":"\u003cdiv class\u003d\"ttypography\"\u003e\u003cp\u003eHi, dear contestants!\u003c/p\u003e\u003cp\u003eWith the end of Codeforces Round #431 (\u003ca href\u003d\"//codeforces.com/contest/848\"\u003eDiv. 1\u003c/a\u003e and \u003ca href\u003d\"//codeforces.com/contest/849\"\u003eDiv. 2\u003c/a\u003e), some might be complaining behind the screen that problems are too tricky or hard, or have been struggling with some supposedly solvable problem... Yes, this time problems seem hard, but anyways, I hope they provided you with something, say rating, fun, ideas, or experience. I don\u0027t want to see anyone losing confidence because of failure (bad luck) in a single contest — please, don\u0027t do so.\u003c/p\u003e\u003cp\u003eHere are the hints, tutorials and codes for the problems. Feel free to discuss about problems in the comments, and point out if something is incorrect or unclear. Thank you!\u003c/p\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/849/problem/A\" title\u003d\"Codeforces Round 431 (Div. 2)\"\u003e849A - Odds and Ends\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eby \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/cyand1317\" title\u003d\"Grandmaster cyand1317\"\u003ecyand1317\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWhat will the whole array satisfy? Is that a sufficient condition?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"849A\"\u003eTutorial is loading...\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eModel solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\nstatic const int MAXN \u003d 102;\n\nint n;\nint a[MAXN];\n\nint main()\n{\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; ++i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]);\n\n    puts((n % 2 \u003d\u003d 1) \u0026amp;\u0026amp; (a[0] % 2 \u003d\u003d 1) \u0026amp;\u0026amp; (a[n - 1] % 2 \u003d\u003d 1) ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/849/problem/B\" title\u003d\"Codeforces Round 431 (Div. 2)\"\u003e849B - Tell Your World\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eby \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/cyand1317\" title\u003d\"Grandmaster cyand1317\"\u003ecyand1317\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFirst way: consider the first three points. What cases are there?\u003c/p\u003e\u003cp\u003eSecond way: consider the first point. Either it\u0027s on a single line alone, or the line that passes through it passes through another point. Iterate over this point.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"849B\"\u003eTutorial is loading...\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTommyr7\u0027s solution (first idea)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n#define eps 1e-7\nusing namespace std;\nint read()\n{\n\tint x\u003d0,f\u003d1;char ch\u003dgetchar();\n\twhile (ch\u0026lt;\u00270\u0027||ch\u0026gt;\u00279\u0027){if (ch\u003d\u003d\u0027-\u0027) f\u003d-1;ch\u003dgetchar();}\n\twhile (ch\u0026gt;\u003d\u00270\u0027\u0026amp;\u0026amp;ch\u0026lt;\u003d\u00279\u0027){x\u003dx*10+ch-\u00270\u0027;ch\u003dgetchar();}\n\treturn x*f;\n}\nint n,a[1007];\nbool vis[1007];\nbool check(double k,int b)\n{\n\tmemset(vis,false,sizeof(vis));\n\tint cnt\u003d0;\n\tfor (int i\u003d1;i\u0026lt;\u003dn;i++)\n\t{\n\t\tif (a[i]-b\u003d\u003d1LL*k*(i-1)) \n\t\t{\n\t\t\tvis[i]\u003dtrue;\n\t\t\t++cnt;\n\t\t}\n\t}\n\tif (cnt\u003d\u003dn) return false;\n\tif (cnt\u003d\u003dn-1) return true;\n\tint pos1\u003d0;\n\tfor (int i\u003d1;i\u0026lt;\u003dn;i++)\n\t\tif (!vis[i]\u0026amp;\u0026amp;pos1\u003d\u003d0) pos1\u003di;\n\tfor (int i\u003dpos1+1;i\u0026lt;\u003dn;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tif (fabs((double)(a[i]-a[pos1])/(i-pos1)-k)\u0026gt;eps) return false;\n\t\t}\n\treturn true;\n}\nint main()\n{\n\tn\u003dread();\n\tfor (int i\u003d1;i\u0026lt;\u003dn;i++)\n\t\ta[i]\u003dread();\n\tbool ans\u003dfalse;\n\tans|\u003dcheck(1.0*(a[2]-a[1]),a[1]);\n\tans|\u003dcheck(0.5*(a[3]-a[1]),a[1]);\n\tans|\u003dcheck(1.0*(a[3]-a[2]),a[2]*2-a[3]);\n\tif (ans) printf(\u0026quot;Yes\\n\u0026quot;); else printf(\u0026quot;No\\n\u0026quot;);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eModel solution (second idea)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nstatic const int MAXN \u003d 1004;\n\nint n;\nint y[MAXN];\n\nbool on_first[MAXN];\n\nbool check()\n{\n    for (int i \u003d 1; i \u0026lt; n; ++i) {\n        for (int j \u003d 0; j \u0026lt; n; ++j) {\n            if ((long long)i * (y[j] - y[0]) \u003d\u003d (long long)j * (y[i] - y[0]))\n                on_first[j] \u003d true;\n            else on_first[j] \u003d false;\n        }\n        int start_idx \u003d -1;\n        bool valid \u003d true;\n        for (int j \u003d 0; j \u0026lt; n; ++j) if (!on_first[j]) {\n            if (start_idx \u003d\u003d -1) {\n                start_idx \u003d j;\n            } else if ((long long)i * (y[j] - y[start_idx]) !\u003d (long long)(j - start_idx) * (y[i] - y[0])) {\n                valid \u003d false; break;\n            }\n        }\n        if (valid \u0026amp;\u0026amp; start_idx !\u003d -1) return true;\n    }\n    return false;\n}\n\nint main()\n{\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n    for (int i \u003d 0; i \u0026lt; n; ++i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;y[i]);\n\n    bool ans \u003d false;\n    ans |\u003d check();\n    std::reverse(y, y + n);\n    ans |\u003d check();\n\n    puts(ans ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/848/problem/A\" title\u003d\"Codeforces Round 431 (Div. 1)\"\u003e848A - From Y to Y\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eby \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/cyand1317\" title\u003d\"Grandmaster cyand1317\"\u003ecyand1317\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFor a given string, how to calculate the cost?\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eMore\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eFor each letter, count how many times it appears in the original string.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"848A\"\u003eTutorial is loading...\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eKalinin\u0027s solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\n\nusing ll \u003d long long;\nusing ld \u003d long double;\nusing D \u003d double;\nusing uint \u003d unsigned int;\ntemplate\u0026lt;typename T\u0026gt;\nusing pair2 \u003d pair\u0026lt;T, T\u0026gt;;\n\n#ifdef WIN32\n    #define LLD \u0026quot;%I64d\u0026quot;\n#else\n    #define LLD \u0026quot;%lld\u0026quot;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nint main()\n{\n    int k;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;k);\n    for (int i \u003d 0; i \u0026lt; 26; i++)\n    {\n        int cnt \u003d 1;\n        while ((cnt + 1) * cnt / 2 \u0026lt;\u003d k) cnt++;\n        k -\u003d cnt * (cnt - 1) / 2;\n        for (int j \u003d 0; j \u0026lt; cnt; j++) printf(\u0026quot;%c\u0026quot;, \u0027a\u0027 + i);\n    }\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eModel solution with knapsack (!)\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;vector\u0026gt;\nstatic const int MAXK \u003d 100002;\nstatic const int INF \u003d 0x3fffffff;\n\nint f[MAXK];\nint pred[MAXK];\n\nint main()\n{\n    f[0] \u003d 0;\n    for (int i \u003d 1; i \u0026lt; MAXK; ++i) f[i] \u003d INF;\n    for (int i \u003d 0; i \u0026lt; MAXK; ++i) pred[i] \u003d -1;\n\n    for (int i \u003d 0; i \u0026lt; MAXK; ++i) if (f[i] !\u003d INF) {\n        for (int j \u003d 2; i + j * (j - 1) / 2 \u0026lt; MAXK; ++j)\n            if (f[i + j * (j - 1) / 2] \u0026gt; f[i] + 1) {\n                f[i + j * (j - 1) / 2] \u003d f[i] + 1;\n                pred[i + j * (j - 1) / 2] \u003d j;\n            }\n    } else printf(\u0026quot;Assertion failed at %d\\n\u0026quot;, i);\n\n    int k;\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;k);\n    if (k \u003d\u003d 0) { puts(\u0026quot;a\u0026quot;); return 0; }\n    std::vector\u0026lt;int\u0026gt; v;\n    for (; k \u0026gt; 0; k -\u003d pred[k] * (pred[k] - 1) / 2) {\n        v.push_back(pred[k]);\n    }\n    for (int i \u003d 0; i \u0026lt; v.size(); ++i) {\n        for (int j \u003d 0; j \u0026lt; v[i]; ++j) putchar(\u0027a\u0027 + i);\n    }\n    putchar(\u0027\\n\u0027);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/848/problem/B\" title\u003d\"Codeforces Round 431 (Div. 1)\"\u003e848B - Rooter\u0027s Song\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eby \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/cyand1317\" title\u003d\"Grandmaster cyand1317\"\u003ecyand1317\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eWhen do dancers collide? What changes and what keeps the same?\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eNext\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eGroup dancers by \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ep\u003c/i\u003e - \u003ci\u003et\u003c/i\u003e\u003c/span\u003e. What happens next?\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"848B\"\u003eTutorial is loading...\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eModel solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;vector\u0026gt;\nstatic const int MAXN \u003d 100004;\nstatic const int MAXW \u003d 100003;\nstatic const int MAXT \u003d 100002;\n\nint n, w, h;\nint g[MAXN], p[MAXN], t[MAXN];\n\nstd::vector\u0026lt;int\u0026gt; s[MAXW + MAXT];\nint ans_x[MAXN], ans_y[MAXN];\n\nint main()\n{\n    scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;n, \u0026amp;w, \u0026amp;h);\n    for (int i \u003d 0; i \u0026lt; n; ++i) {\n        scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;g[i], \u0026amp;p[i], \u0026amp;t[i]);\n        s[p[i] - t[i] + MAXT].push_back(i);\n    }\n\n    std::vector\u0026lt;int\u0026gt; xs, ys;\n    for (int i \u003d 0; i \u0026lt; MAXW + MAXT; ++i) if (!s[i].empty()) {\n        for (int u : s[i]) {\n            if (g[u] \u003d\u003d 1) xs.push_back(p[u]);\n            else ys.push_back(p[u]);\n        }\n        std::sort(xs.begin(), xs.end());\n        std::sort(ys.begin(), ys.end());\n        std::sort(s[i].begin(), s[i].end(), [] (int u, int v) {\n            if (g[u] !\u003d g[v]) return (g[u] \u003d\u003d 2);\n            else return (g[u] \u003d\u003d 2 ? p[u] \u0026gt; p[v] : p[u] \u0026lt; p[v]);\n        });\n        for (int j \u003d 0; j \u0026lt; xs.size(); ++j) {\n            ans_x[s[i][j]] \u003d xs[j];\n            ans_y[s[i][j]] \u003d h;\n        }\n        for (int j \u003d 0; j \u0026lt; ys.size(); ++j) {\n            ans_x[s[i][j + xs.size()]] \u003d w;\n            ans_y[s[i][j + xs.size()]] \u003d ys[ys.size() - j - 1];\n        }\n        xs.clear();\n        ys.clear();\n    }\n\n    for (int i \u003d 0; i \u0026lt; n; ++i) printf(\u0026quot;%d %d\\n\u0026quot;, ans_x[i], ans_y[i]);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/848/problem/C\" title\u003d\"Codeforces Round 431 (Div. 1)\"\u003e848C - Goodbye Souvenir\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eby \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/adedalic\" title\u003d\"Master adedalic\"\u003eadedalic\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eDifference between last occurrence and first occurrence equals the sum of differences between pairs of adjacent occurrences. Handle this with some segment tree, or even non-standard size block decomposition, say sizes of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eO\u003c/i\u003e(\u003ci\u003en\u003c/i\u003e\u003csup class\u003d\"upper-index\"\u003e2 / 3\u003c/sup\u003e)\u003c/span\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"848C\"\u003eTutorial is loading...\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eModel solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\n#define fore(i, l, r) for(int i \u003d int(l); i \u0026lt; int(r); i++)\n#define forn(i, n) fore(i, 0, n)\n\n#define all(a) (a).begin(), (a).end()\n#define sqr(a) ((a) * (a))\n#define sz(a) int(a.size())\n#define mp make_pair\n#define pb push_back\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntemplate\u0026lt;class A, class B\u0026gt; ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp;out, const pair\u0026lt;A, B\u0026gt; \u0026amp;p) {\n\treturn out \u0026lt;\u0026lt; \u0026quot;(\u0026quot; \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; p.second \u0026lt;\u0026lt; \u0026quot;)\u0026quot;;\n}\n\ntemplate\u0026lt;class A\u0026gt; ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp;out, const vector\u0026lt;A\u0026gt; \u0026amp;v) {\n\tout \u0026lt;\u0026lt; \u0026quot;[\u0026quot;;\n\tforn(i, sz(v)) {\n\t\tif(i \u0026gt; 0)\n\t\t\tout \u0026lt;\u0026lt; \u0026quot; \u0026quot;;\n\t\tout \u0026lt;\u0026lt; v[i];\n\t}\n\treturn out \u0026lt;\u0026lt; \u0026quot;]\u0026quot;;\n}\n\nmt19937 myRand(time(NULL));\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair\u0026lt;int, int\u0026gt; pt;\n\ninline int gett() {\n\treturn clock() * 1000 / CLOCKS_PER_SEC;\n}\n\nconst ld EPS \u003d 1e-9;\nconst int INF \u003d int(1e9);\nconst li INF64 \u003d li(INF) * INF;\nconst ld PI \u003d 3.1415926535897932384626433832795;\n\nconst int N \u003d 100 * 1000 + 555;\n\nint n, m, aa[N], a[N];\nint qt[N], qx[N], qy[N];\n\ninline bool read() {\n\tif(!(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m))\n\t\treturn false;\n\t\n\tforn(i, n)\n\t\tassert(scanf(\u0026quot;%d\u0026quot;, \u0026amp;aa[i]) \u003d\u003d 1);\n\t\t\n\tforn(i, m) {\n\t\tassert(scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;qt[i], \u0026amp;qx[i], \u0026amp;qy[i]) \u003d\u003d 3);\n\t\tqx[i]--;\n\t}\n\t\t\n\treturn true;\n}\n\nvector\u0026lt;int\u0026gt; vars[4 * N];\nvector\u0026lt;li\u0026gt; f[4 * N];\nli sumAll[4 * N];\n\ninline void addValF(int k, int pos, int val) {\n\tsumAll[k] +\u003d val;\n\tfor(; pos \u0026lt; sz(f[k]); pos |\u003d pos + 1)\n\t\tf[k][pos] +\u003d val;\n}\n\ninline li sum(int k, int pos) {\n\tli ans \u003d 0;\n\tfor(; pos \u0026gt;\u003d 0; pos \u003d (pos \u0026amp; (pos + 1)) - 1)\n\t\tans +\u003d f[k][pos];\n\t\t\n\treturn ans;\n}\n\ninline li getSumF(int k, int pos) {\n\treturn sumAll[k] - sum(k, pos - 1);\n}\n\nli getSumST(int v, int l, int r, int lf, int rg, int val) {\n\tif(l \u0026gt;\u003d r || lf \u0026gt;\u003d rg)\n\t\treturn 0;\n\t\t\n\tif(l \u003d\u003d lf \u0026amp;\u0026amp; r \u003d\u003d rg) {\n\t\tint pos \u003d int(lower_bound(all(vars[v]), val) - vars[v].begin());\n\t\treturn getSumF(v, pos);\n\t}\n\t\n\tint mid \u003d (l + r) \u0026gt;\u0026gt; 1;\n\t\n\tli ans \u003d 0;\n\tif(lf \u0026lt; mid)\n\t\tans +\u003d getSumST(2 * v + 1, l, mid, lf, min(mid, rg), val);\n\tif(rg \u0026gt; mid)\n\t\tans +\u003d getSumST(2 * v + 2, mid, r, max(lf, mid), rg, val);\n\t\t\n\treturn ans;\n}\n\nvoid addValST(int k, int v, int l, int r, int pos, int pos2, int val) {\n\tif(l \u0026gt;\u003d r)\n\t\treturn;\n\t\t\n\tif(!k)\n\t\tvars[v].pb(pos2);\n\telse {\n\t\tint cpos \u003d int(lower_bound(all(vars[v]), pos2) - vars[v].begin());\n\t\taddValF(v, cpos, val);\n\t}\n\t\n\tif(l + 1 \u003d\u003d r) {\n\t\tassert(l \u003d\u003d pos);\n\t\treturn;\n\t}\n\t\n\tint mid \u003d (l + r) \u0026gt;\u0026gt; 1;\n\t\n\tif(pos \u0026lt; mid)\n\t\taddValST(k, 2 * v + 1, l, mid, pos, pos2, val);\n\telse\n\t\taddValST(k, 2 * v + 2, mid, r, pos, pos2, val);\n}\n\nint pr[N];\nset\u0026lt;int\u0026gt; ids[N];\n\nvoid build(int k, int v, int l, int r) {\n\tfore(i, l, r)\n\t\tif(!k)\n\t\t\tvars[v].pb(pr[i]);\n\t\telse {\n\t\t\tint pos \u003d int(lower_bound(all(vars[v]), pr[i]) - vars[v].begin());\n\t\t\taddValF(v, pos, i - pr[i]);\n\t\t}\n\t\t\t\n\tif(l + 1 \u003d\u003d r)\n\t\treturn;\n\t\t\n\tint mid \u003d (l + r) \u0026gt;\u0026gt; 1;\n\t\n\tbuild(k, 2 * v + 1, l, mid);\n\tbuild(k, 2 * v + 2, mid, r);\n}\n\ninline void eraseSets(int k, int pos) {\n\taddValST(k, 0, 0, n, pos, pr[pos], -(pos - pr[pos]));\n\tids[ a[pos] ].erase(pos);\n\t\n\tauto it2 \u003d ids[ a[pos] ].lower_bound(pos);\n\t\n\tif(it2 !\u003d ids[ a[pos] ].end()) {\n\t\tint np \u003d *it2;\n\t\tassert(a[np] \u003d\u003d a[pos]);\n\t\tassert(pr[np] \u003d\u003d pos);\n\t\t\n\t\taddValST(k, 0, 0, n, np, pr[np], -(np - pr[np]));\n\t\t\n\t\tpr[np] \u003d pr[pos];\n\t\taddValST(k, 0, 0, n, np, pr[np], +(np - pr[np]));\n\t}\n\t\n\ta[pos] \u003d -1;\n\tpr[pos] \u003d -1;\n}\n\ninline void insertSets(int k, int pos, int nval) {\n\tauto it2 \u003d ids[nval].lower_bound(pos);\n\tassert(it2 \u003d\u003d ids[nval].end() || *it2 \u0026gt; pos);\n\t\n\tif(it2 !\u003d ids[nval].end()) {\n\t\tint np \u003d *it2;\n\t\tassert(a[np] \u003d\u003d nval);\n\t\t\n\t\taddValST(k, 0, 0, n, np, pr[np], -(np - pr[np]));\n\n\t\tpr[np] \u003d pos;\n\t\taddValST(k, 0, 0, n, np, pr[np], +(np - pr[np]));\n\t}\n\t\n\tpr[pos] \u003d -1;\n\tif(it2 !\u003d ids[nval].begin()) {\n\t\tauto it1 \u003d it2; it1--;\n\t\tassert(*it1 \u0026lt; pos);\n\t\t\n\t\tpr[pos] \u003d *it1;\n\t}\n\taddValST(k, 0, 0, n, pos, pr[pos], +(pos - pr[pos]));\n\t\n\tids[nval].insert(pos);\n\ta[pos] \u003d nval;\n}\n\ninline void precalc() {\n\tforn(v, 4 * N) {\n\t\tsort(all(vars[v]));\n\t\tvars[v].erase(unique(all(vars[v])), vars[v].end());\n\t\t\n\t\tf[v].assign(sz(vars[v]), 0);\n\t\tsumAll[v] \u003d 0;\n\t}\n}\n\ninline void solve() {\n\tforn(k, 2) {\n\t\tif(k) precalc();\n\t\t\n\t\tforn(i, N)\n\t\t\tids[i].clear();\n\t\tforn(i, n)\n\t\t\ta[i] \u003d aa[i];\n\t\t\t\n\t\tvector\u0026lt;int\u0026gt; ls(n + 1, -1);\n\t\tforn(i, n) {\n\t\t\tpr[i] \u003d ls[ a[i] ];\n\t\t\tls[ a[i] ] \u003d i;\n\t\t\t\n\t\t\tids[ a[i] ].insert(i);\n\t\t}\n\t\t\n\t\tbuild(k, 0, 0, n);\n\t\t\n//\t\tcerr \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; clock() \u0026lt;\u0026lt; endl;\n\t\t\n\t\tforn(q, m) {\n\t\t\tif(qt[q] \u003d\u003d 1) {\n\t\t\t\teraseSets(k, qx[q]);\n\t\t\t\tinsertSets(k, qx[q], qy[q]);\n\t\t\t} else\n\t\t\t\tif(k) printf(\u0026quot;%I64d\\n\u0026quot;, getSumST(0, 0, n, qx[q], qy[q], qx[q]));\n\t\t}\n\t\t\n//\t\tcerr \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; clock() \u0026lt;\u0026lt; endl;\n\t}\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\n\tfreopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\n\t\n\tint t \u003d gett();\n#endif\n\n\tsrand(time(NULL));\n\tcout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(10);\n\n\twhile(read()) {\n\t\tsolve();\t\n\t\t\n#ifdef _DEBUG\n\t\tcerr \u0026lt;\u0026lt; \u0026quot;TIME \u003d \u0026quot; \u0026lt;\u0026lt; gett() - t \u0026lt;\u0026lt; endl;\n\t\tt \u003d gett();\n#endif\n\t}\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/848/problem/D\" title\u003d\"Codeforces Round 431 (Div. 1)\"\u003e848D - Shake It!\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eby \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/cyand1317\" title\u003d\"Grandmaster cyand1317\"\u003ecyand1317\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eUse DP. \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ef\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e keeps the number of subgraphs with \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ei\u003c/i\u003e\u003c/span\u003e operations and a minimum cut of \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003ej\u003c/i\u003e\u003c/span\u003e. The transition may be in a knapsack-like manner. Add more functions (say another \u003cspan class\u003d\"tex-span\"\u003e\u003ci\u003eg\u003c/i\u003e[\u003ci\u003ei\u003c/i\u003e][\u003ci\u003ej\u003c/i\u003e]\u003c/span\u003e) if needed to make it faster.\u003c/p\u003e\u003cp\u003eThere are more than one way to do DP, you can also read about other nice solutions \u003ca href\u003d\"//codeforces.com/blog/entry/54214?#comment-383006\"\u003ehere\u003c/a\u003e and \u003ca href\u003d\"//codeforces.com/blog/entry/54214?#comment-383035\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"848D\"\u003eTutorial is loading...\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eModel solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstring\u0026gt;\ntypedef long long int64;\nstatic const int MAXN \u003d 53;\nstatic const int MODULUS \u003d 1e9 + 7;\n#define _  %  MODULUS\n#define __ %\u003d MODULUS\n\nint n, m;\n// f[# of operations][mincut] -- total number of graphs\n// g[# of operations][mincut] -- number of ordered pairs of two graphs\nint64 f[MAXN][MAXN] \u003d {{ 0 }}, g[MAXN][MAXN] \u003d {{ 0 }};\nint64 h[MAXN][MAXN];\n\ninline int64 qpow(int64 base, int exp) {\n    int64 ans \u003d 1;\n    for (; exp; exp \u0026gt;\u0026gt;\u003d 1, (base *\u003d base)__) if (exp \u0026amp; 1) (ans *\u003d base)__;\n    return ans;\n}\nint64 inv[MAXN];\n\nint main()\n{\n    for (int i \u003d 0; i \u0026lt; MAXN; ++i) inv[i] \u003d qpow(i, MODULUS - 2);\n\n    scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m);\n\n    f[0][1] \u003d 1;\n    for (int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n        for (int j \u003d 1; j \u0026lt;\u003d i + 1; ++j) {\n            // Calculate g[i][*]\n            // pair(i)(j) \u003d graph(p)(r) in series with graph(q)(s)\n            // where p+q \u003d\u003d i-1, min(r, s) \u003d\u003d j\n            for (int p \u003d 0; p \u0026lt;\u003d i - 1; ++p) {\n                int q \u003d i - 1 - p;\n                for (int r \u003d j; r \u0026lt;\u003d p + 1; ++r)\n                    (g[i][j] +\u003d (int64)f[p][r] * f[q][j])__;\n                for (int s \u003d j + 1; s \u0026lt;\u003d q + 1; ++s)\n                    (g[i][j] +\u003d (int64)f[p][j] * f[q][s])__;\n            }\n            // Update all f with g[i][*]\n            // Iterate over the number of times pair(i)(j) is appended in parallel, let it be t\n            // h is used as a temporary array\n            memset(h, 0, sizeof h);\n            for (int p \u003d 0; p \u0026lt;\u003d n; ++p)\n                for (int q \u003d 1; q \u0026lt;\u003d p + 1; ++q) {\n                    int64 comb \u003d 1;\n                    for (int t \u003d 1; p + t * i \u0026lt;\u003d n; ++t) {\n                        comb \u003d comb * (g[i][j] + t - 1)_ * inv[t]_;\n                        (h[p + t * i][q + t * j] +\u003d f[p][q] * comb)__;\n                    }\n                }\n            for (int p \u003d 0; p \u0026lt;\u003d n; ++p)\n                for (int q \u003d 1; q \u0026lt;\u003d p + 1; ++q)\n                    (f[p][q] +\u003d h[p][q])__;\n        }\n    }\n\n    printf(\u0026quot;%lld\\n\u0026quot;, f[n][m]);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch3\u003e\u003ca href\u003d\"/contest/848/problem/E\" title\u003d\"Codeforces Round 431 (Div. 1)\"\u003e848E - Days of Floral Colours\u003c/a\u003e\u003c/h3\u003e\u003cp\u003eby \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/cyand1317\" title\u003d\"Grandmaster cyand1317\"\u003ecyand1317\u003c/a\u003e\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eHint\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eBreak the circle down into semicircles. Then there will be 1D/1D recurrences over several functions.\u003c/p\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eLast insight\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003eUse FFT in a divide-and-conquer manner to optimize it.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eTutorial\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cdiv class\u003d\"problemTutorial\" problemcode\u003d\"848E\"\u003eTutorial is loading...\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eO(n^2) solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\ntypedef long long int64;\nstatic const int MAXN \u003d 50004;\nstatic const int MODULUS \u003d 998244353;\n#define _  %  MODULUS\n#define __ %\u003d MODULUS\n\nint n;\nint64 g[MAXN];\nint64 f0[MAXN], f1[MAXN], f2[MAXN];\n\nint main()\n{\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\n    g[0] \u003d 1;\n    g[2] \u003d 1;\n    for (int i \u003d 4; i \u0026lt;\u003d n; i +\u003d 2) g[i] \u003d (g[i - 4] + g[i - 2])_;\n\n    f0[0] \u003d 0;\n    f1[0] \u003d 1;\n    f2[0] \u003d 4;\n    for (int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n        f0[i] \u003d g[i] * i _ * i _;\n        for (int j \u003d 1; j \u0026lt;\u003d i - 2; ++j) {\n            f0[i] +\u003d g[j] * j _ * j _ * f0[i - j - 1]_;\n            f0[i] +\u003d g[j - 1] * j _ * j _ * f1[i - j - 2]_;\n        }\n        f1[i] \u003d g[i] * (i + 1)_ * (i + 1)_ + f0[i - 1];\n        for (int j \u003d 1; j \u0026lt;\u003d i - 2; ++j) {\n            f1[i] +\u003d g[j] * (j + 1)_ * (j + 1)_ * f0[i - j - 1]_;\n            f1[i] +\u003d g[j - 1] * (j + 1)_ * (j + 1)_ * f1[i - j - 2]_;\n        }\n        f0[i]__; f1[i]__;\n    }\n    for (int i \u003d 1; i \u0026lt;\u003d n; ++i) {\n        f2[i] \u003d g[i] * (i + 2)_ * (i + 2)_ + f1[i - 1];\n        for (int j \u003d 1; j \u0026lt;\u003d i - 1; ++j) {\n            f2[i] +\u003d g[j] * (j + 1)_ * (j + 1)_ * f1[i - j - 1]_;\n            f2[i] +\u003d g[j - 1] * (j + 1)_ * (j + 1)_ * f2[i - j - 2]_;\n        }\n        f2[i]__;\n    }\n\n    int64 ans \u003d 0;\n\n    ans +\u003d (g[n - 1] + g[n - 3]) * (n - 1)_ * (n - 1)_ * n _;\n    for (int i \u003d 2; i \u0026lt;\u003d n - 2; ++i) {\n        ans +\u003d g[i - 1] * (i - 1)_ * (i - 1)_ * f0[n - i - 1]_ * i _;\n        ans +\u003d g[i - 2] * (i - 1)_ * (i - 1)_ * f1[n - i - 2]_ * 2 * i _;\n        if (i \u0026gt;\u003d 3 \u0026amp;\u0026amp; i \u0026lt;\u003d n - 3)\n            ans +\u003d g[i - 3] * (i - 1)_ * (i - 1)_ * f2[n - i - 3]_ * i _;\n    }\n\n    printf(\u0026quot;%lld\\n\u0026quot;, ans _);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eModel solution\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cpre\u003e\u003ccode\u003e#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstring\u0026gt;\ntypedef long long int64;\nstatic const int LOGN \u003d 18;\nstatic const int MAXN \u003d 1 \u0026lt;\u0026lt; LOGN;\nstatic const int MODULUS \u003d 998244353;\nstatic const int PRIMITIVE \u003d 2192;\n#define _  %  MODULUS\n#define __ %\u003d MODULUS\ntemplate \u0026lt;typename T\u0026gt; inline void swap(T \u0026amp;a, T \u0026amp;b) { static T t; t \u003d a; a \u003d b; b \u003d t; }\n\nint n;\nint64 g[MAXN];\nint64 g0[MAXN], g1[MAXN], g2[MAXN];\nint64 f0[MAXN], f1[MAXN], f2[MAXN];\n\nint64 q0[MAXN], q1[MAXN];\nint64 t1[MAXN], t2[MAXN], t3[MAXN], t4[MAXN];\n\ninline int qpow(int64 base, int exp)\n{\n    int64 ans \u003d 1;\n    for (; exp; exp \u0026gt;\u0026gt;\u003d 1) { if (exp \u0026amp; 1) (ans *\u003d base)__; (base *\u003d base)__; }\n    return ans;\n}\n\nint bitrev[LOGN][MAXN];\nint root[2][LOGN];\ninline void fft(int n, int64 *a, int direction)\n{\n    int s \u003d __builtin_ctz(n);\n    int64 u, v, r, w;\n    for (int i \u003d 0; i \u0026lt; n; ++i) if (i \u0026lt; bitrev[s][i]) swap(a[i], a[bitrev[s][i]]);\n    for (int i \u003d 1; i \u0026lt;\u003d n; i \u0026lt;\u0026lt;\u003d 1)\n        for (int j \u003d 0; j \u0026lt; n; j +\u003d i) {\n            r \u003d root[direction \u003d\u003d -1][__builtin_ctz(i)];\n            w \u003d 1;\n            for (int k \u003d j; k \u0026lt; j + (i \u0026gt;\u0026gt; 1); ++k) {\n                u \u003d a[k];\n                v \u003d (a[k + (i \u0026gt;\u0026gt; 1)] * w)_;\n                a[k] \u003d (u + v)_;\n                a[k + (i \u0026gt;\u0026gt; 1)] \u003d (u - v + MODULUS)_;\n                w \u003d (w * r)_;\n            }\n        }\n}\n\ninline void convolve(int n, int64 *a, int64 *b, int64 *c)\n{\n    static int64 a1[MAXN], b1[MAXN];\n    memcpy(a1, a, n * 2 * sizeof(int64));\n    memcpy(b1, b, n * 2 * sizeof(int64));\n    memset(a + n, 0, n * sizeof(int64));\n    memset(b + n, 0, n * sizeof(int64));\n    fft(n * 2, a, +1);\n    fft(n * 2, b, +1);\n    int64 q \u003d qpow(n * 2, MODULUS - 2);\n    for (int i \u003d 0; i \u0026lt; n * 2; ++i) c[i] \u003d a[i] * b[i]_;\n    fft(n * 2, c, -1);\n    for (int i \u003d 0; i \u0026lt; n; ++i) c[i] \u003d c[i] * q _;\n    memcpy(a, a1, n * 2 * sizeof(int64));\n    memcpy(b, b1, n * 2 * sizeof(int64));\n}\n\n// Calcukates f0 and f1.\nvoid solve_1(int l, int r)\n{\n    if (l \u003d\u003d r) {\n        (f0[l] +\u003d g0[l])__;\n        (f1[l] +\u003d g1[l])__;\n        return;\n    }\n\n    int m \u003d (l + r) \u0026gt;\u0026gt; 1;\n\n    solve_1(l, m);\n\n    int len \u003d 1;\n    while (len \u0026lt; r - l + 1) len \u0026lt;\u0026lt;\u003d 1;\n    for (int i \u003d 0; i \u0026lt; len; ++i) q0[i] \u003d (i + l \u0026lt;\u003d m ? f0[i + l] : 0);\n    for (int i \u003d 0; i \u0026lt; len; ++i) q1[i] \u003d (i + l \u0026lt;\u003d m ? f1[i + l] : 0);\n    for (int i \u003d len; i \u0026lt; len * 2; ++i) q0[i] \u003d q1[i] \u003d 0;\n    convolve(len, g0, q0, t1);\n    convolve(len, g1, q0, t2);\n    convolve(len, g1, q1, t3);\n    convolve(len, g2, q1, t4);\n\n    for (int i \u003d 0; i \u0026lt; len; ++i) {\n        if (i + l \u0026gt;\u003d m + 1 - 1 \u0026amp;\u0026amp; i + l \u0026lt;\u003d r - 1) {\n            (f0[i + l + 1] +\u003d t1[i])__;\n            (f1[i + l + 1] +\u003d t2[i])__;\n        }\n        if (i + l \u0026gt;\u003d m + 1 - 3 \u0026amp;\u0026amp; i + l \u0026lt;\u003d r - 3) {\n            (f0[i + l + 3] +\u003d t3[i])__;\n            (f1[i + l + 3] +\u003d t4[i])__;\n        }\n    }\n\n    solve_1(m + 1, r);\n}\n\n// Calculates f2.\nvoid solve_2(int l, int r)\n{\n    if (l \u003d\u003d r) {\n        (f2[l] +\u003d (g2[l] + (l \u0026gt;\u003d 1 ? t1[l - 1] : 0)))__;\n        return;\n    }\n\n    int m \u003d (l + r) \u0026gt;\u0026gt; 1;\n\n    solve_2(l, m);\n\n    int len \u003d 1;\n    while (len \u0026lt; r - l + 1) len \u0026lt;\u0026lt;\u003d 1;\n    for (int i \u003d 0; i \u0026lt; len; ++i) q0[i] \u003d (i + l \u0026lt;\u003d m ? f2[i + l] : 0);\n    for (int i \u003d len; i \u0026lt; len * 2; ++i) q0[i] \u003d 0;\n    convolve(len, g2, q0, t2);\n\n    for (int i \u003d 0; i \u0026lt; len; ++i) {\n        if (i + l \u0026gt;\u003d m + 1 - 3 \u0026amp;\u0026amp; i + l \u0026lt;\u003d r - 3) {\n            (f2[i + l + 3] +\u003d t2[i])__;\n        }\n    }\n\n    solve_2(m + 1, r);\n}\n\nint main()\n{\n    for (int s \u003d 0; s \u0026lt; LOGN; ++s)\n        for (int i \u003d 0; i \u0026lt; (1 \u0026lt;\u0026lt; s); ++i)\n            bitrev[s][i] \u003d (bitrev[s][i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1) | ((i \u0026amp; 1) \u0026lt;\u0026lt; (s - 1));\n    for (int i \u003d 0; i \u0026lt; LOGN; ++i) {\n        root[0][i] \u003d qpow(PRIMITIVE, MAXN \u0026gt;\u0026gt; i);\n        root[1][i] \u003d qpow(PRIMITIVE, MAXN - (MAXN \u0026gt;\u0026gt; i));\n    }\n\n    scanf(\u0026quot;%d\u0026quot;, \u0026amp;n);\n\n    g[0] \u003d 1;\n    g[2] \u003d 1;\n    for (int i \u003d 4; i \u0026lt;\u003d n; i +\u003d 2) g[i] \u003d (g[i - 4] + g[i - 2])_;\n    for (int i \u003d 0; i \u0026lt;\u003d n; ++i) {\n        g0[i] \u003d g[i] * i _ * i _;\n        g1[i] \u003d g[i] * (i + 1)_ * (i + 1)_;\n        g2[i] \u003d g[i] * (i + 2)_ * (i + 2)_;\n    }\n\n    solve_1(0, n);\n\n    int len \u003d 1;\n    while (len \u0026lt; n) len \u0026lt;\u0026lt;\u003d 1;\n    convolve(len, g1, f1, t1);\n    solve_2(0, n);\n\n    int64 ans \u003d 0;\n\n    ans +\u003d (g[n - 1] + g[n - 3]) * (n - 1)_ * (n - 1)_ * n _;\n    for (int i \u003d 2; i \u0026lt;\u003d n - 2; ++i) {\n        ans +\u003d g0[i - 1] * f0[n - i - 1]_ * i _;\n        ans +\u003d g1[i - 2] * f1[n - i - 2]_ * 2 * i _;\n        if (i \u0026gt;\u003d 3 \u0026amp;\u0026amp; i \u0026lt;\u003d n - 3)\n            ans +\u003d g2[i - 3] * f2[n - i - 3]_ * i _;\n    }\n\n    printf(\u0026quot;%lld\\n\u0026quot;, ans _);\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003ch2\u003eBehind the scene and random things (read if tired of problemsolving)\u003c/h2\u003e \u003cdiv class\u003d\"spoiler\"\u003e\u003cb class\u003d\"spoiler-title\"\u003eExpand\u003c/b\u003e\u003cdiv class\u003d\"spoiler-content\" style\u003d\"display: none;\"\u003e\u003cp\u003ePerhaps some may have noticed that at the end of \u003ca href\u003d\"//codeforces.com/blog/entry/52449\"\u003eeditorial of #418\u003c/a\u003e it\u0027s written that\u003c/p\u003e \u003cblockquote\u003e\u003cp\u003eProbably it will be for Ha...\u003c/p\u003e \u003c/blockquote\u003e\u003cp\u003eYes, I had had ideas for the last four problems for Div. 2 by that time. Then I came up with Div. 2 A when lying on bed one night, seems I underestimated its trickiness :/\u003c/p\u003e\u003cp\u003e(1 September 2017 is also when the story of \u003cstrong\u003eHa\u003c/strong\u003erry Potter ends, so to me seems like a great coincidence?)\u003c/p\u003e\u003cp\u003eAfter my unsuccessful performance at the National Olympiad (that\u0027s another thing to talk about), on that evening when everything seemed dull, I changed Div. 1 E to what it looks like now — it used to be Div. 1 C or so. \u0026quot;I\u0027m poor at problemsolving. This is the hardest I can come up with,\u0026quot; I thought, \u0026quot;and if it doesn\u0027t qualify then I\u0027d better give up on holding a round with Div. 1.\u0026quot;\u003c/p\u003e\u003cp\u003eThen in early August I created the proposal with all problems. After it was reviewed, some of them were changed, moved or replaced, and I ended up having no Div. 1 D. I had an idea and put it to Div. 1 D, but we had difficulty distinguishing different complexities, so it was set aside and replaced with the problem from \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/adedalic\" title\u003d\"Master adedalic\"\u003eadedalic\u003c/a\u003e. Schoolwork kept disrupting me from working on preparation, but I managed to allocate time to do it all for my own problems (except tutorials, :P). \u003ca class\u003d\"rated-user user-orange\" href\u003d\"/profile/adedalic\" title\u003d\"Master adedalic\"\u003eadedalic\u003c/a\u003e\u0027s problem is prepared by him and \u003ca class\u003d\"rated-user user-red\" href\u003d\"/profile/KAN\" title\u003d\"Grandmaster KAN\"\u003eKAN\u003c/a\u003e, thank you!\u003c/p\u003e\u003cp\u003eThen two hours before the contest, it was suggested that swapping Div. 1 C and Div. 1 D would be good. I had\u0027t had enough time to test the new problem myself, but I thought the second division may prefer data structures to multidimensional DP and agreed. Then Div. 1 contestants jump from A to C and had unfavourable luck... My sympathy, hope you have enjoyed the problems themselves.\u003c/p\u003e\u003cp\u003eThese are random fragments of the story behind this round. It wouldn\u0027t have been possible without you, dear contestants and members of the community. My deep gratitude!\u003c/p\u003e\u003cp\u003eAlso, the problems feature songs created by songwriters and the voice of Hatsune Miku. Let it be happy or sad, separation or reunion, the problems are all inspired by the songs at the very beginning (not necessarily contents though, for example 2A and 1E are just related to the songs in title). Here\u0027s the list if you\u0027re interested.\u003c/p\u003e \u003cul\u003e   \u003cli\u003e\u003ca href\u003d\"http://vocadb.net/S/15662\"\u003e\u003cem\u003eODDS\u0026amp;ENDS\u003c/em\u003e\u003c/a\u003e by ryo\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://vocadb.net/S/8395\"\u003e\u003cem\u003eTell Your World\u003c/em\u003e\u003c/a\u003e by kz\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://vocadb.net/S/4230\"\u003e\u003cem\u003efrom Y to Y\u003c/em\u003e\u003c/a\u003e by OneRoom\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://vocadb.net/S/71159\"\u003e\u003cem\u003eRooter\u0027s Song\u003c/em\u003e\u003c/a\u003e by DECO*27\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://vocadb.net/S/110348\"\u003e\u003cem\u003eSayonara Souvenir\u003c/em\u003e\u003c/a\u003e (Goodbye Souvenir) by Toa\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://vocadb.net/S/11593\"\u003e\u003cem\u003eshake it!\u003c/em\u003e\u003c/a\u003e by emon(Tes.)\u003c/li\u003e   \u003cli\u003e\u003ca href\u003d\"http://vocadb.net/S/39300\"\u003e\u003cem\u003eHanairo Biyori\u003c/em\u003e\u003c/a\u003e (Flower Colored Weather) by Natsume Chiaki\u003c/li\u003e \u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003eThank you for reading. Next round? Perhaps something more traditional, who knows? Believe me, I\u0027ll try harder if this happens.\u003c/p\u003e\u003cp\u003eCheers! \\(^ ^)/\u003c/p\u003e \u003chr /\u003e\u003cp\u003e\u003cstrong\u003eUPD\u003c/strong\u003e Packages for problems are uploaded. They are in Polygon format and contain everything including statements, tests \u0026amp; generators, validators \u0026amp; checkers, and solutions. You can download them from \u003ca href\u003d\"https://drive.google.com/drive/folders/0B5z87ZbXNZyEcXBtSVhWbDJEN00?usp\u003dsharing\"\u003eGoogle Drive\u003c/a\u003e or \u003ca href\u003d\"https://pan.baidu.com/s/1eSJ68gE\"\u003eBaidu Drive\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e","tags":["431","editorial"]}}